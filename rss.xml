<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
  <title>Obachuka</title>
  <link>http://obachuka.com</link>
  <description>Obachuka's personal website</description>
  <atom:link href="http://obachuka.com/rss.xml" rel="self" type="application/rss+xml" />
  <language>en</language>

  <item>
    <title>Magic replays</title>
    <link>http://obachuka.com/2016/07/07/</link>
    <description><![CDATA[<p>I was able to implement replays by writing the memory and inputs to a file, then reading them back in. I'm beginning to appreciate the power of C. Being able to manipulate arbitrary bits of memory made this really easy. I did this in less than an hour. Now I'm able record myself, make a change in the code, and see the effects in real time. Compile times are also fast, and I don't think my code base will ever get big enough for longer compile times.</p> <p>Meanwhile at work, it took me four hours to compile some Python code because of dependency hell. I actually have to build the Python code every time I want to see my changes, because the janky build system does some black magic file copying and linking. The build takes a few seconds, completely removing one of the best things about dynamic languages: no compile time.</p> <p>I like personal projects because I can keep them small. Look at this.</p> <video autoplay loop><source src="https://zippy.gfycat.com/MeanGrandEnglishpointer.webm" type="video/webm"></video> <p>Looks like magic.</p>]]></description>
    <guid>http://obachuka.com/2016/07/07/</guid>
  </item>

  <item>
    <title>Figured out webm</title>
    <link>http://obachuka.com/2016/07/06/</link>
    <description><![CDATA[<video controls><source src="https://zippy.gfycat.com/PeacefulGiganticAngelwingmussel.webm" type="video/webm"></video>
]]></description>
    <guid>http://obachuka.com/2016/07/06/</guid>
  </item>

  <item>
    <title>Buncha red dots</title>
    <link>http://obachuka.com/2016/07/05/</link>
    <description><![CDATA[<p>For the longest time, I spent a lot of time hemming and hawing and hewing about what kind of entity system to use for my game. I used to use an inheritance hierarchy back in college, but object oriented programming has been falling out, especially with game programming. It wasn't very flexible and wrecked the cache. The two most common entity systems I see today are arrays of structs (entities) that owned other structs (components), or arrays of components, and entities are just indices that map to these components.</p> <p>I eventually realized though, that trying to make a generic solution that worked for anything was dumb. Since I've already made several prototypes back in college, I already knew what my game was about, I just had to program it (again). I had six different enemy entities, one explosion entity, one player entity, and occasionally in different versions of my prototypes, I had one or two miscellaneous entities. But eventually, I realized all my entities had the same data, and only behaved differently. So now I'm just making one type of entity, and stack allocating a giant array for everything. Then based on the position of the array, I call different functions on the entities. It's very easy to do and cache friendly. It's not at all flexible, but since I already have the scope of my game figured out, I don't need the flexibility.</p> <p>And here's a screenshot of my game. It's jut a bunch of red squares for now. But I'm getting there.</p> <img src="http://i.imgur.com/HqCQAkW.png">]]></description>
    <guid>http://obachuka.com/2016/07/05/</guid>
  </item>

  <item>
    <title>A game a month</title>
    <link>http://obachuka.com/2016/07/04/</link>
    <description><![CDATA[<p>My original plan was to practice drawing on the weekdays and work on code on the weeknds, and my goal was to release a short but finished video game every month. Looking at the progress I made this weekend, working only 2-3 days on a game per week isn't enough to finish it within a month. So I'll have to hold off on my drawings and code on the weekdays as well. Maybe once I get faster at this, I can pick up drawing again.</p> <p>The problem with code is that it's harder to show off than art, especially if I can't open source it. I'll have to get capture software and record my game. Tomorrow I'll have a gif to share.</p> ]]></description>
    <guid>http://obachuka.com/2016/07/04/</guid>
  </item>

  <item>
    <title>Screen resolutions</title>
    <link>http://obachuka.com/2016/07/03/</link>
    <description><![CDATA[<p>Something I've always wondered was how 2D games handled screen resolutions. For 3D games, it doesn't matter as much since polygons can be scaled up, but images can't. I've seen <i>Transistor</i> master their art at both 720p and 1080p. Requiring HD at minimum seems common for modern games, which is reasonable. I doubt gamers will be using tiny screens, and even if they did, they should be well aware that some games just don't work on small screens.</p> <p>But what about aspect ratio? For some games, elements can be rearranged, but for games like side-scrolling shooters, changing the aspect ratio would affect the gameplay since the screen acts as the boundary for the playing field. This is a problem I'm having with my current game. I use vertical bars, but can't decide what to put in them. Having black bars is just ugly.</p> <p>Also, I won't be uploading anymore code. Even though I think it should be fine, I'm worried about the legal side of things.</p>]]></description>
    <guid>http://obachuka.com/2016/07/03/</guid>
  </item>

</channel>
</rss>

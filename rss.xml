<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
  <title>Obachuka</title>
  <link>http://obachuka.com</link>
  <description>Obachuka's personal website</description>
  <atom:link href="http://obachuka.com/rss.xml" rel="self" type="application/rss+xml" />
  <language>en</language>

  <item>
    <title>Broken grid</title>
    <link>http://obachuka.com/2016/07/08/</link>
    <description><![CDATA[<p>I normally implement a quadtree for spatial partitioning, and did so for my last implementation of this game. But my quadtree ended up being evenly divided all the time, since the location of my game entities were roughly evenly distributed. So this time, I tried to go for a simple grid. Below, I've divided the space into four cells, one for each corner, and highlighted in purple all the squares in the bottom right corner.</p> <img src="http://i.imgur.com/CJm7rqc.png"/> <p>As you can see, that is not at all the bottom right corner. I'll have to debug this tomorrow.</p>]]></description>
    <guid>http://obachuka.com/2016/07/08/</guid>
  </item>

  <item>
    <title>Magic replays</title>
    <link>http://obachuka.com/2016/07/07/</link>
    <description><![CDATA[<p>I was able to implement replays by writing the memory and inputs to a file, then reading them back in. I'm beginning to appreciate the power of C. Being able to manipulate arbitrary bits of memory made this really easy. I did this in less than an hour. Now I'm able record myself, make a change in the code, and see the effects in real time. Compile times are also fast, and I don't think my code base will ever get big enough for longer compile times.</p> <p>Meanwhile at work, it took me four hours to compile some Python code because of dependency hell. I actually have to build the Python code every time I want to see my changes, because the janky build system does some black magic file copying and linking. The build takes a few seconds, completely removing one of the best things about dynamic languages: no compile time.</p> <p>I like personal projects because I can keep them small. Look at this.</p> <video autoplay loop><source src="https://zippy.gfycat.com/MeanGrandEnglishpointer.webm" type="video/webm"></video> <p>Looks like magic.</p>]]></description>
    <guid>http://obachuka.com/2016/07/07/</guid>
  </item>

  <item>
    <title>Figured out webm</title>
    <link>http://obachuka.com/2016/07/06/</link>
    <description><![CDATA[<video controls><source src="https://zippy.gfycat.com/PeacefulGiganticAngelwingmussel.webm" type="video/webm"></video>
]]></description>
    <guid>http://obachuka.com/2016/07/06/</guid>
  </item>

  <item>
    <title>Buncha red dots</title>
    <link>http://obachuka.com/2016/07/05/</link>
    <description><![CDATA[<p>For the longest time, I spent a lot of time hemming and hawing and hewing about what kind of entity system to use for my game. I used to use an inheritance hierarchy back in college, but object oriented programming has been falling out, especially with game programming. It wasn't very flexible and wrecked the cache. The two most common entity systems I see today are arrays of structs (entities) that owned other structs (components), or arrays of components, and entities are just indices that map to these components.</p> <p>I eventually realized though, that trying to make a generic solution that worked for anything was dumb. Since I've already made several prototypes back in college, I already knew what my game was about, I just had to program it (again). I had six different enemy entities, one explosion entity, one player entity, and occasionally in different versions of my prototypes, I had one or two miscellaneous entities. But eventually, I realized all my entities had the same data, and only behaved differently. So now I'm just making one type of entity, and stack allocating a giant array for everything. Then based on the position of the array, I call different functions on the entities. It's very easy to do and cache friendly. It's not at all flexible, but since I already have the scope of my game figured out, I don't need the flexibility.</p> <p>And here's a screenshot of my game. It's jut a bunch of red squares for now. But I'm getting there.</p> <img src="http://i.imgur.com/HqCQAkW.png">]]></description>
    <guid>http://obachuka.com/2016/07/05/</guid>
  </item>

  <item>
    <title>A game a month</title>
    <link>http://obachuka.com/2016/07/04/</link>
    <description><![CDATA[<p>My original plan was to practice drawing on the weekdays and work on code on the weeknds, and my goal was to release a short but finished video game every month. Looking at the progress I made this weekend, working only 2-3 days on a game per week isn't enough to finish it within a month. So I'll have to hold off on my drawings and code on the weekdays as well. Maybe once I get faster at this, I can pick up drawing again.</p> <p>The problem with code is that it's harder to show off than art, especially if I can't open source it. I'll have to get capture software and record my game. Tomorrow I'll have a gif to share.</p> ]]></description>
    <guid>http://obachuka.com/2016/07/04/</guid>
  </item>

</channel>
</rss>
